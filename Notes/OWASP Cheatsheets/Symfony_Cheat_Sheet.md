---
title: "Symfony Cheat Sheet"
source: "[[_content/dictionary#O|OWASP]] Cheatsheet"
source_url: "https://cheatsheetseries.owasp.org/cheatsheets/Symfony_Cheat_Sheet.html"
created: "1741872882.1623478"
tags: [owasp, cheatsheet, security]
---
# Symfony

## Symfony Cheat Sheet[[[[[[[[[[[[[[[[[[[[[[¶](#references)](#summary)](#sensitive-data)](#error-handling-disclosure)](#authentication)](#session-cookies-management)](#security-related-headers)](#cross-origin-resource-sharing-cors)](#dependencies-vulnerabilities)](#directory-traversal)](#store-uploaded-files-securely)](#use-unique-filenames)](#validate-file-type-and-size)](#file-upload-vulnerabilities)](#open-redirection)](#command-injection)](#sql-injection)](#cross-site-request-forgery-csrf)](#cross-site-scripting-xss)](#main-sections)](#introduction)](#symfony-cheat-sheet)
### Introduction¶
This cheat sheet aims to provide developers with security tips when building applications using the Symfony framework.
It covers common vulnerabilities and best practices to ensure that your Symfony applications are secure.
While Symfony comes with built-in security mechanisms, developers must be aware of potential vulnerabilities and best practices to ensure the applications they build are secure.
This guide aims to cover common security issues, emphasizing the importance of understanding Symfony's security features and how to utilize them effectively.
Whether you're a newcomer to Symfony or an experienced developer looking to reinforce your security practices, this document serves as a valuable resource.
By following the guidelines outlined here, you can strengthen the security of your Symfony applications and create a safer digital environment for users and data.
### Main Sections¶
#### Cross-Site Scripting ([[_content/dictionary#X|XSS]])¶
Cross-Site Scripting (XSS) is a type of attack where malicious [[_content/dictionary#J|JavaScript]] code is injected into a displayed variable.
For example, if the value of the variable name is <script>alert('hello')</script>, and we display it in [[_content/dictionary#H|HTML]] like this: Hello {{name}}, the injected script will be executed when the HTML is rendered.
Symfony comes by default with twig templates that automatically protect applications from XSS attacks by using output escaping to transform variables containing special characters by wrapping the variable with {{ }} statement.
<p>Hello {{name}}</p>
{# if 'name' is '<script>alert('hello!')</script>', Twig will output this:
'<p>Hello &lt;script&gt;alert(&#39;hello!&#39;)&lt;/script&gt;</p>' #}

If you are rendering a variable that is trusted and contains [[_content/dictionary#H|HTML]] contents, you can use Twig raw filter to disable output escaping.
<p>{{ product.title|raw }}</p>
{# if 'product.title' is 'Lorem <strong>Ipsum</strong>', Twig will output
exactly that instead of 'Lorem &lt;strong&gt;Ipsum&lt;/strong&gt;' #}

Explore the [Twig output escaping documentation](https://twig.symfony.com/doc/3.x/api.html#escaper-extension) to gain insights into disabling output escaping for a specific block or an entire template.
For other information on [[_content/dictionary#X|XSS]] prevention that is not specific to Symfony, you may refer to the [[Cross_Site_Scripting_Prevention_Cheat_Sheet|Cross Site Scripting Prevention Cheatsheet]].
#### Cross-Site Request Forgery ([[_content/dictionary#C|CSRF]])¶
Symfony Form component automatically includes CSRF tokens in the forms, providing built-in protection against CSRF attacks.
Symfony validates these tokens automatically, eliminating the need for manual intervention to safeguard your application.
By default the CSRF token is added as a hidden field called _token, but this can be customized with other settings on a form-by-form basis:
use Symfony\Component\Form\[[_content/dictionary#A|AbstractType]];
use Symfony\Component\[[_content/dictionary#O|OptionsResolver]]\OptionsResolver;

class [[_content/dictionary#P|PostForm]] extends [[_content/dictionary#A|AbstractType]]
{

    public function configureOptions([[_content/dictionary#O|OptionsResolver]] $resolver): void
    {
        $resolver->setDefaults([
            // ... 
            'csrf_protection' => true,  // enable/disable csrf protection for this form
            'csrf_field_name' => '_csrf_token',
            'csrf_token_id'   => 'post_item', // change arbitrary string used to generate
        ]);
    }

}

If you don't use Symfony Forms you can generate and validate [[_content/dictionary#C|CSRF]] tokens by yourself. To do this you have to install symfony/security-csrf component.
composer install symfony/security-csrf

Enable/disable the [[_content/dictionary#C|CSRF]] protection in config/packages/framework.yaml file:
framework:
    csrf_protection: ~

Next, consider this [[_content/dictionary#H|HTML]] Twig template when a [[_content/dictionary#C|CSRF]] token is generated by the csrf_token() Twig function
<form action="{{ url('delete_post', { id: post.id }) }}" method="post">
    <input type="hidden" name="token" value="{{ csrf_token('delete-post') }}">
    <button type="submit">Delete post</button>
</form>

Then you can get the value of the [[_content/dictionary#C|CSRF]] token in the controller using the isCsrfTokenValid() function:
use App\Entity\Post;
use Symfony\Bundle\[[_content/dictionary#F|FrameworkBundle]]\Controller\[[_content/dictionary#A|AbstractController]];
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class [[_content/dictionary#E|ExampleController]] extends [[_content/dictionary#A|AbstractController]]
{

    #[Route('/posts/{id}', methods: ['[[_content/dictionary#D|DELETE]]'], name: 'delete_post')]
    public function delete(Post $post, Request $request): Response 
    { 
        $token = $request->request->get('token')
        if($this->isCsrfTokenValid($token)) {
            // ...
        }

        // ...
    }
}

You can find more information about [[_content/dictionary#C|CSRF]] not related to Symfony in [[Cross-Site_Request_Forgery_Prevention_Cheat_Sheet|Cross-Site Request Forgery (CSRF) Cheat Sheet]].
#### [[_content/dictionary#S|SQL]] Injection¶
SQL Injection is a type of security vulnerability that occurs when an attacker is able to manipulate a SQL query in a way that it can execute arbitrary SQL code.
This can allow attackers to view, modify, or delete data in the database, potentially leading to unauthorized access or data loss.
Symfony, particularly when used with Doctrine [[_content/dictionary#O|ORM]] (Object-Relational Mapping), provides protection against SQL injection through prepared statements parameters.
Thanks to this it is harder to mistakenly write unprotected queries, however, it is still possible.
The following example shows insecure [[_content/dictionary#D|DQL]] usage:
use Doctrine\ORM\[[_content/dictionary#E|EntityManagerInterface]];
use Symfony\Bundle\[[_content/dictionary#F|FrameworkBundle]]\Controller\[[_content/dictionary#A|AbstractController]];
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Request;
use Symfony\Component\HttpFoundation\Response;

class [[_content/dictionary#E|ExampleController]] extends [[_content/dictionary#A|AbstractController]] {

    public function getPost(Request $request, [[_content/dictionary#E|EntityManagerInterface]] $em): Response
    {
        $id = $request->query->get('id');

        $dql = "[[_content/dictionary#S|SELECT]] p [[_content/dictionary#F|FROM]] App\Entity\Post p [[_content/dictionary#W|WHERE]] p.id = " . $id . ";";
        $query = $em->createQuery($dql);
        $post = $query->getSingleResult();

        // ...
    }
}

The examples below show the correct ways to provide protection against [[_content/dictionary#S|SQL]] Injection:

- Using entity repository built-in method

$id = $request->query->get('id');
$post = $em->getRepository(Post::class)->findOneBy(['id' => $id]);

- Using Doctrine [[_content/dictionary#D|DQL]] Language

$query = $em->createQuery("[[_content/dictionary#S|SELECT]] p [[_content/dictionary#F|FROM]] App\Entity\Post p [[_content/dictionary#W|WHERE]] p.id = :id");
$query->setParameter('id', $id);
$post = $query->getSingleResult();

- Using [[_content/dictionary#D|DBAL]] Query Builder

$qb = $em->createQueryBuilder();
$post = $qb->select('p')
            ->from('posts','p')
            ->where('id = :id')
            ->setParameter('id', $id)
            ->getQuery()
            ->getSingleResult();

For more information about Doctrine, you can refer to [their documentation](https://www.doctrine-project.org/index.html).
You may also refer to the [[SQL_Injection_Prevention_Cheat_Sheet|[[_content/dictionary#S|SQL]] Injection Prevention Cheatsheet]] for more information that is not specific to either Symfony or Doctrine.
#### Command Injection¶
Command Injection occurs when malicious code is injected into an application system and executed.
For more information refer to [[OS_Command_Injection_Defense_Cheat_Sheet|Command Injection Defense Cheat Sheet]].
Consider the following example, where a file is removed using the exec() function without any input escaping:
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\[[_content/dictionary#H|HttpKernel]]\Attribute\[[_content/dictionary#A|AsController]];
use Symfony\Component\Routing\Annotation\Route;

#[[[_content/dictionary#A|AsController]]]
class [[_content/dictionary#E|ExampleController]] 
{

    #[Route('/remove_file', methods: ['[[_content/dictionary#P|POST]]'])]
    public function removeFile(Request $request): Response
    {
        $filename =  $request->request->get('filename');
        exec(sprintf('rm %s', $filename));

        // ...
    }
}

In the above code, there is no validation of the user's input. Imagine what could happen if the user provides a malicious value like test.txt && rm -rf . . To mitigate this risk, it is advisable to use native [[_content/dictionary#P|PHP]] functions like in this case unlink() or Symfony Filesystem Component remove() method instead of exec().
For specific PHP filesystem functions relevant to your case, you can refer to the [PHP documentation](https://www.php.net/manual/en/refs.fileprocess.file.php) or [Symfony Filesystem Component documentation](https://symfony.com/doc/current/components/filesystem.html).
#### Open Redirection¶
Open Redirection is a security flaw that occurs when a web application redirects users to a [[_content/dictionary#U|URL]] specified in an invalidated parameter. Attackers exploit this vulnerability to redirect users to malicious sites.
In the provided PHP code snippet:
use Symfony\Bundle\[[_content/dictionary#F|FrameworkBundle]]\Controller\[[_content/dictionary#A|AbstractController]];
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\[[_content/dictionary#H|HttpKernel]]\Attribute\[[_content/dictionary#M|MapQueryParameter]];
use Symfony\Component\Routing\Annotation\Route;

class [[_content/dictionary#E|ExampleController]] extends [[_content/dictionary#A|AbstractController]] 
{

    #[Route('/dynamic_redirect', methods: ['[[_content/dictionary#G|GET]]'])]
    public function dynamicRedirect(#[[[_content/dictionary#M|MapQueryParameter]]] string $url): Response 
    {
        return $this->redirect($url);
    }
}

The controller function redirects users based on the url query parameter without proper validation. Attackers can craft malicious URLs, leading unsuspecting users to malicious sites. To prevent open redirection, always validate and sanitize user input before redirection, and avoid using untrusted input directly in redirect functions.
#### File Upload Vulnerabilities¶
File upload vulnerabilities are security issues that arise when an application does not properly validate and handle file uploads. It's important to ensure that file uploads are handled securely to prevent various types of attacks. Here are some general guidelines to help mitigate this issue in Symfony:
##### Validate file type and size¶
Always validate the file type on the server side to ensure that only allowed file types are accepted.
Also, consider limiting the size of uploaded files to prevent denial-of-service attacks and to ensure that your server has enough resources to handle the uploads.
Example with [[_content/dictionary#P|PHP]] Attributes:
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\File\[[_content/dictionary#U|UploadedFile]];
use Symfony\Component\Validator\Constraints\File;

class [[_content/dictionary#U|UploadDto]]
{
    public function __construct(
        #[File(
            maxSize: '1024k',
            mimeTypes: [
                'application/pdf',
                'application/x-pdf',
            ],
        )]
        public readonly [[_content/dictionary#U|UploadedFile]] $file,
    ){}
}

Example with Symfony Form:
use Symfony\Component\Form\[[_content/dictionary#A|AbstractType]];
use Symfony\Component\Form\Extension\Core\Type\[[_content/dictionary#F|FileType]];
use Symfony\Component\Form\[[_content/dictionary#F|FormBuilderInterface]];
use Symfony\Component\Validator\Constraints\File;

class [[_content/dictionary#F|FileForm]] extends [[_content/dictionary#A|AbstractType]]
{
    public function buildForm([[_content/dictionary#F|FormBuilderInterface]] $builder, array $options)
    {
        $builder
            ->add('file', [[_content/dictionary#F|FileType]]::class, [
                'constraints' => [
                    new File([
                        'maxSize' => '1024k', 
                        'mimeTypes' => [
                            'application/pdf',
                            'application/x-pdf',
                        ],
                    ]),
                ],
            ]);
    }
}

##### Use unique filenames¶
Ensure that each uploaded file has a unique name to prevent overwriting existing files. You can use a combination of a unique identifier and the original filename to generate a unique name.
##### Store uploaded files securely¶
Store uploaded files outside the public directory to prevent direct access. If you use a public directory to store them, configure your web server to deny access to the upload directory.
Refer to the [[File_Upload_Cheat_Sheet|File Upload Cheatsheet]] to learn more.
#### Directory Traversal¶
A directory or path traversal attack aims to access files and directories that are stored on a server by manipulating input data that reference files with “../” dot-dot-slash sequences and its variations or by using absolute file paths.
For more details refer to [[[_content/dictionary#O|OWASP]] Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
You can protect your application from a directory traversal attack by validating whether the absolute path of the requested file location is correct or strip out the directory information from filename input.

- Check if the path exists using the [[_content/dictionary#P|PHP]] realpath function and check that it leads to the storage directory

use Symfony\Bundle\[[_content/dictionary#F|FrameworkBundle]]\Controller\[[_content/dictionary#A|AbstractController]];
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Response;
use Symfony\Component\[[_content/dictionary#H|HttpKernel]]\Attribute\[[_content/dictionary#M|MapQueryParameter]];
use Symfony\Component\Routing\Annotation\Route;

class [[_content/dictionary#E|ExampleController]] extends [[_content/dictionary#A|AbstractController]] 
{

    #[Route('/download', methods: ['[[_content/dictionary#G|GET]]'])]
    public function download(#[[[_content/dictionary#M|MapQueryParameter]]] string $filename): Response 
    {
        $storagePath = $this->getParameter('kernel.project_dir') . '/storage';
        $filePath = $storagePath . '/' . $filename;

        $realBase = realpath($storagePath);
        $realPath = realpath($filePath);

        if ($realPath === false || !str_starts_with($realPath, $realBase))
        {
            //Directory Traversal!
        }

        // ...

    }
}

- Strip out directory information with [[_content/dictionary#P|PHP]] basename function

// ...

$storagePath = $this->getParameter('kernel.project_dir') . '/storage';
$filePath = $storagePath . '/' . basename($filename);

// ...

#### Dependencies vulnerabilities¶
Dependency vulnerabilities can expose your application to various risks, making it crucial to adopt best practices.
Keep all Symfony components and third-party libraries up-to-date.
Composer, the dependency manager for [[_content/dictionary#P|PHP]] makes it easy to update PHP packages:
composer update

When using multiple dependencies, some of them may contain security vulnerabilities.
To address this concern, Symfony comes with [[Symfony Security](https://symfony.com/doc/current/security.html) Checker](https://symfony.com/doc/current/setup.html#checking-security-vulnerabilities). This tool specifically examines the composer.lock file in your project to identify any known security vulnerabilities within the dependencies that have been installed and address any potential security issues in your Symfony project.
To use Security Checker run the following command using [Symfony [[_content/dictionary#C|CLI]]](https://github.com/symfony-cli/symfony-cli):
symfony check:security

You should also consider similar tools:

[- Local [[_content/dictionary#P|PHP]] Security Checker](https://github.com/fabpot/local-php-security-checker)

[- Enlightn Security Checker](https://github.com/enlightn/security-checker)

#### Cross-Origin Resource Sharing ([[_content/dictionary#C|CORS]])¶
CORS is a security feature implemented in web browsers to control how web applications in one domain can request and interact with resources hosted on other domains.
In Symfony, you can manage CORS policies using nelmio/cors-bundle. This bundle lets you control CORS rules precisely without changing your server settings.
To install it with Composer, run:
composer require nelmio/cors-bundle

For Symfony Flex users, the installation generates a basic configuration file in the config/packages directory automatically. Take a look at the example configuration for routes starting with /[[_content/dictionary#A|API]] prefix.
# config/packages/nelmio_cors.yaml
nelmio_cors:
    defaults:
        origin_regex: true
        allow_origin: ['*']
        allow_methods: ['[[_content/dictionary#G|GET]]', '[[_content/dictionary#O|OPTIONS]]', '[[_content/dictionary#P|POST]]', '[[_content/dictionary#P|PUT]]', '[[_content/dictionary#P|PATCH]]', '[[_content/dictionary#D|DELETE]]']
        allow_headers: ['*']
        expose_headers: ['Link']
        max_age: 3600
    paths:
        '^/api': ~  # ~ means that configurations for this path is inherited from defaults

#### Security-related Headers¶
It's advisable to enhance the security of your Symfony application by adding to your responses essential security headers as:

- Strict-Transport-Security
- X-Frame-Options
- X-Content-Type-Options
- Content-Security-Policy
- X-Permitted-Cross-Domain-Policies
- Referrer-Policy
- Clear-Site-Data
- Cross-Origin-Embedder-Policy
- Cross-Origin-Opener-Policy
- Cross-Origin-Resource-Policy
- Cache-Control

To find more details about individual headers refer to the [[[_content/dictionary#O|OWASP]] secure headers project](https://owasp.org/www-project-secure-headers/).
In Symfony, you can add those headers either manually or automatically by listening the [[[_content/dictionary#R|ResponseEvent]]](https://symfony.com/doc/current/reference/events.html#kernel-response) to your to every response or configuring web servers like Nginx or Apache.
use Symfony\Component\[[_content/dictionary#H|HttpFoundation]]\Request;

$response = new Response();
$response->headers->set('X-Frame-Options', '[[_content/dictionary#S|SAMEORIGIN]]');

#### Session & Cookies Management¶
By default, sessions are securely configured and enabled. However, they can be controlled manually in config/packages/framework.yaml under the framework.session key. Make sure to set the following in your session configuration to make your application more aware.
Ensure cookie_secure is not explicitly set to false(it is set to true by default). Setting http only to true means that the cookie won't be accessible by [[_content/dictionary#J|JavaScript]].
cookie_httponly: true

Make sure to set a short session [[_content/dictionary#T|TTL]] duration. According to [[Session_Management_Cheat_Sheet|[[_content/dictionary#O|OWASP]]'s recommendations]], aim for a session TTL of 2-5 minutes for high-value applications and 15-30 minutes for lower-risk applications.
cookie_lifetime: 5

It is recommended to set cookie_samesite to either lax or strict to prevent cookies from being sent from cross-origin requests. lax allows the cookie to be sent along with "safe" top-level navigations and same-site requests. With strict  it would not be possible to send any cookie when the [[_content/dictionary#H|HTTP]] request is not from the same domain.
cookie_samesite: lax|strict

Setting cookie_secure to auto assures us that cookies are only sent over secure connections, meaning true for [[_content/dictionary#H|HTTPS]] and false for [[_content/dictionary#H|HTTP]] protocol.
cookie_secure: auto

[[_content/dictionary#O|OWASP]] provides more general information about sessions in [[Session_Management_Cheat_Sheet|Session Management Cheat Sheet]].
You may also refer to the [Cookie Security Guide](https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20171130_Cookie_Security_Myths_Misconceptions_David_Johansson.pdf).

In Symfony, sessions are managed by the framework itself and rely on Symfony's session handling mechanisms rather than [[_content/dictionary#P|PHP]]'s default session handling via the session.auto_start = 1 directive in the php.ini file.
The session.auto_start = 1 directive in PHP is used to automatically start a session on each request, bypassing explicit calls to session_start(). However, when using Symfony for session management, it's recommended to disable session.auto_start to prevent conflicts and unexpected behavior.
#### Authentication¶
Symfony Security provides a robust authentication system that includes providers, firewalls, and access controls to ensure a secure and controlled access environment. Authentication settings can be configured in config/packages/security.yaml.

Providers
Symfony authentication relies on providers to fetch user information from various storage types such as databases, [[_content/dictionary#L|LDAP]], or custom sources. Providers get users based on the defined property and load the corresponding user object.
In the example below [Entity User Provider](https://symfony.com/doc/current/security/user_providers.html#security-entity-user-provider) is presented which uses Doctrine to fetch user by unique identifier.
providers:
    app_user_provider:
        entity:
            class: App\Entity\User
            property: email

- Firewalls
Symfony uses firewalls to define security configurations for different parts of an application. Each firewall defines a specific set of rules and actions for incoming requests. They protect different sections of the application by specifying which routes or URLs are secured, the authentication mechanisms to use, and how to handle unauthorized access. A firewall can be associated with specific patterns, request methods, access controls, and authentication providers.
firewalls:
    dev: # disable security on routes used in development env
        pattern: ^/(_(profiler|wdt)|css|images|js)/
        security: false
    admin: # handle authentication in /admin pattern routes
        lazy: true
        provider: app_user_provider
        pattern: ^/admin
        custom_authenticator: App\Security\[[_content/dictionary#A|AdminAuthenticator]]
        logout:
            path: app_logout
            target: app_login
    main: # main firewall that include all remaining routes
        lazy: true
        provider: app_user_provider

- Access Control
Access control determines which users can access specific parts of an application. These rules consist of path patterns and required roles or permissions. Access control rules are configured under access_control key.
access_control:
    - { path: ^/admin, roles: ROLE_ADMIN } # only user with ROLE_ADMIN role is allowed
    - { path: ^/login, roles: PUBLIC_ACCESS } # everyone can access this route

#### Error Handling Disclosure¶
Symfony has a robust error-handling system. By default, Symfony applications are configured to display detailed error messages only in the development environment for security reasons. In the production environment, a generic error page is shown. Symfony's error handling system also allows customized error pages based on different [[_content/dictionary#H|HTTP]] status codes, providing a seamless and branded user experience. Additionally, Symfony logs detailed error information, aiding developers in identifying and resolving issues efficiently.
For more information about error handling unrelated to Symfony refer to [[Error_Handling_Cheat_Sheet|Error Handling Cheat Sheet]].
#### Sensitive data¶
In Symfony, the best way to store configurations like [[_content/dictionary#A|API]] keys, etc., is through the use of environment variables, which are dependent on the application's location.
To ensure the security of sensitive values, Symfony provides a secrets management system in which values are additionally encoded using cryptographic keys and stored as secrets.
Consider an example where an API_KEY is stored as a secret:
To generate a pair of cryptographic keys you can run the following command. The private key file is highly sensitive and it shouldn't be committed in a repository.
bin/console secrets:generate-keys

This command will generate a file for the API_KEY secret in config/secrets/env(dev|prod|etc.)
bin/console secret:set API_KEY

You can access secret values in your code in the same manner as environment variables.
It's very important to note that if there are environment variables and secrets with identical names, the values from environment variables will always override secrets.
For more details refer to [Symfony Secrets Documentation](https://symfony.com/doc/current/configuration/secrets.html).
#### Summary¶

- Make sure your app is not in debug mode while in production. To turn off debug mode, set your APP_ENV environment variable to prod:
APP_ENV=prod

Make sure your [[_content/dictionary#P|PHP]] configuration is secure. You may refer to the [[PHP_Configuration_Cheat_Sheet|PHP Configuration Cheat Sheet]] for more information on secure PHP configuration settings.

- Ensure that the [[_content/dictionary#S|SSL]] certificate is properly configured in your web server and configure it to enforce [[_content/dictionary#H|HTTPS]] by redirecting [[_content/dictionary#H|HTTP]] traffic to HTTPS.

- Implement security headers to enhance the security posture of your application.

- Ensure that file and directory permissions are set correctly to minimize security risks.

- Implement regular backups of your production database and critical files. Have a recovery plan in place to quickly restore your application in case of any issues.

- Use security checkers to scan your dependencies to identify known vulnerabilities.

Consider setting up monitoring tools and error reporting mechanisms to quickly identify and address issues in your production environment. Explore tools like [Blackfire.io](https://www.blackfire.io).

### References¶

[- Symfony [[_content/dictionary#C|CSRF]] Documentation](https://symfony.com/doc/current/security/csrf.html)
[- Symfony Twig Documentation](https://symfony.com/doc/current/templates.html)
[- Symfony Validation Documentation](https://symfony.com/doc/current/validation.html)
[- Symfony Blackfire Documentation](https://symfony.com/doc/current/the-fast-track/en/29-performance.html)
[- Doctrine Security Documentation](https://www.doctrine-project.org/projects/doctrine-dbal/en/3.7/reference/security.html)